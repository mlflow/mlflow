import DatabricksCallout from "@site/src/components/DatabricksCallout"
import { APILink } from "@site/src/components/APILink";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Track Users & Sessions

<DatabricksCallout docsPath="/mlflow3/genai/tracing/track-users-sessions/index" />

Tracking users and sessions in your GenAI application provides essential context for understanding user behavior, analyzing conversation flows, and improving personalization. MLflow offers built-in support for associating traces with users and grouping them into sessions.

## Why Track Users and Sessions?

User and session tracking enables powerful analytics and improvements:

**User Behavior Analysis**: Understand how different users interact with your application and identify usage patterns

**Conversation Flow Tracking**: Analyze multi-turn conversations and context retention across interactions

**Personalization Insights**: Identify patterns to improve user-specific experiences and recommendations

**Quality Per User**: Track performance metrics across different user segments and demographics

**Session Continuity**: Maintain context across multiple interactions within the same conversation

**A/B Testing**: Compare how different user groups respond to application changes or features

## Standard MLflow Tags

MLflow provides two standard tags specifically designed for session and user tracking:

- **`mlflow.trace.user`**: Associates traces with specific users for user-centric analysis
- **`mlflow.trace.session`**: Groups traces belonging to multi-turn conversations or sessions

When you use these standard tags, MLflow automatically enables filtering and grouping capabilities in the UI, making it easy to analyze user and session data.

## Basic Implementation

<Tabs>
  <TabItem value="simple-example" label="Simple Example" default>
    Here's how to add user and session tracking to your application:

    ```python
    import mlflow


    @mlflow.trace
    def chat_completion(user_id: str, session_id: str, message: str):
        """Process a chat message with user and session tracking."""

        # Add user and session context to the current trace
        mlflow.update_current_trace(
            tags={
                "mlflow.trace.user": user_id,  # Links trace to specific user
                "mlflow.trace.session": session_id,  # Groups trace with conversation
            }
        )

        # Your chat logic here
        response = generate_response(message)
        return response


    # Example usage
    def handle_user_message(request):
        return chat_completion(
            user_id=request.user_id,  # e.g., "user-123"
            session_id=request.session_id,  # e.g., "session-abc-456"
            message=request.message,
        )
    ```

    **Key points:**
    - The `@mlflow.trace` decorator automatically creates a trace for function execution
    - <APILink fn="mlflow.update_current_trace" /> adds the user ID and session ID to the active trace
    - Use consistent ID formats across your application for reliable analysis
  </TabItem>
  <TabItem value="context-manager" label="Using Context Managers">
    For more complex scenarios, you can use context managers to ensure consistent user and session tracking:

    ```python
    import mlflow
    from contextlib import contextmanager


    @contextmanager
    def user_session_context(user_id: str, session_id: str, **additional_context):
        """Context manager that automatically adds user and session tracking"""

        # Base user and session tags
        context_tags = {
            "mlflow.trace.user": user_id,
            "mlflow.trace.session": session_id,
        }

        # Add any additional context
        context_tags.update(additional_context)

        with mlflow.start_span(name="user_interaction", attributes=context_tags) as span:
            # Add tags to trace level as well
            mlflow.update_current_trace(tags=context_tags)
            yield span


    # Usage
    def process_user_request(user_id: str, session_id: str, request_data: dict):
        with user_session_context(
            user_id=user_id, session_id=session_id, user_tier="premium", request_type="chat"
        ):
            # Your application logic here
            return handle_request(request_data)
    ```
  </TabItem>
  <TabItem value="web-app" label="Web Application Example">
    In production web applications, you typically extract user and session information from request headers or authentication:

    ```python
    import mlflow
    import os
    from fastapi import FastAPI, Request
    from pydantic import BaseModel

    app = FastAPI()


    class ChatRequest(BaseModel):
        message: str


    @mlflow.trace
    @app.post("/chat")
    def handle_chat(request: Request, chat_request: ChatRequest):
        # Extract user and session context from headers
        client_request_id = request.headers.get("X-Request-ID")
        session_id = request.headers.get("X-Session-ID")
        user_id = request.headers.get("X-User-ID")

        # Update the current trace with comprehensive context
        mlflow.update_current_trace(
            client_request_id=client_request_id,
            tags={
                # Standard MLflow tags for user and session tracking
                "mlflow.trace.session": session_id,
                "mlflow.trace.user": user_id,
                # Additional context
                "environment": os.getenv("ENVIRONMENT", "development"),
                "app_version": os.getenv("APP_VERSION", "1.0.0"),
                "user_agent": request.headers.get("User-Agent"),
                "endpoint": "/chat",
            },
        )

        # Your application logic for processing the chat message
        response_text = process_chat_message(chat_request.message, user_id, session_id)

        return {"response": response_text}


    # To run this example:
    # uvicorn your_file_name:app --reload

    if __name__ == "__main__":
        import uvicorn

        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```

    **Example request with context headers:**
    ```bash
    curl -X POST "http://127.0.0.1:8000/chat" \
         -H "Content-Type: application/json" \
         -H "X-Request-ID: req-abc-123-xyz-789" \
         -H "X-Session-ID: session-def-456-uvw-012" \
         -H "X-User-ID: user-jane-doe-12345" \
         -d '{"message": "What is my account balance?"}'
    ```
  </TabItem>
</Tabs>

## Querying and Analyzing Data

### Using the MLflow UI

Filter traces in the MLflow UI using these search queries:

```
# Find all traces for a specific user
tags.mlflow.trace.user = 'user-123'

# Find all traces in a session
tags.mlflow.trace.session = 'session-abc-456'

# Find traces for a user within a specific session
tags.mlflow.trace.user = 'user-123' AND tags.mlflow.trace.session = 'session-abc-456'

# Find traces for premium users
tags.mlflow.trace.user = 'user-123' AND tags.user_tier = 'premium'
```

The MLflow UI provides powerful filtering and grouping capabilities when you use the standard user and session tags.

### Programmatic Analysis

Use the MLflow SDK to analyze user and session data programmatically for custom analytics and reporting:

<Tabs>
  <TabItem value="user-analysis" label="User Behavior Analysis" default>
    ```python
    import mlflow
    from mlflow import MlflowClient


    def analyze_user_behavior(user_id: str, experiment_id: str):
        """Analyze a specific user's interaction patterns."""

        # Search for all traces from a specific user
        user_traces = mlflow.search_traces(
            experiment_ids=[experiment_id],
            filter_string=f"tags.mlflow.trace.user = '{user_id}'",
        )

        if user_traces.empty:
            return {"error": "No traces found for user"}

        # Calculate key metrics
        total_interactions = len(user_traces)
        unique_sessions = (
            user_traces["tags"]
            .apply(lambda x: x.get("mlflow.trace.session") if isinstance(x, dict) else None)
            .nunique()
        )

        # Performance metrics
        successful_traces = user_traces[user_traces["status"] == "OK"]
        avg_response_time = (
            successful_traces["execution_time_ms"].mean()
            if not successful_traces.empty
            else 0
        )
        error_rate = ((len(user_traces) - len(successful_traces)) / len(user_traces)) * 100

        return {
            "user_id": user_id,
            "total_interactions": total_interactions,
            "unique_sessions": unique_sessions,
            "avg_response_time_ms": avg_response_time,
            "error_rate_percent": error_rate,
            "time_range": {
                "start": user_traces["timestamp_ms"].min(),
                "end": user_traces["timestamp_ms"].max(),
            },
        }


    # Usage
    user_stats = analyze_user_behavior("user-123", "1")
    print(
        f"User has {user_stats['total_interactions']} interactions across {user_stats['unique_sessions']} sessions"
    )
    ```
  </TabItem>
  <TabItem value="session-analysis" label="Session Flow Analysis">
    ```python
    def analyze_session_flow(session_id: str, experiment_id: str):
        """Analyze conversation flow within a session."""

        # Get all traces from a session, ordered chronologically
        session_traces = mlflow.search_traces(
            experiment_ids=[experiment_id],
            filter_string=f"tags.mlflow.trace.session = '{session_id}'",
            order_by=["timestamp_ms ASC"],
        )

        if session_traces.empty:
            return {"error": "No traces found for session"}

        # Build conversation timeline
        conversation_turns = []
        for i, (_, trace) in enumerate(session_traces.iterrows()):
            conversation_turns.append(
                {
                    "turn": i + 1,
                    "timestamp": trace["timestamp_ms"],
                    "duration_ms": trace["execution_time_ms"],
                    "status": trace["status"],
                    "request_preview": str(trace.get("request", ""))[:100] + "..."
                    if trace.get("request")
                    else None,
                    "response_preview": str(trace.get("response", ""))[:100] + "..."
                    if trace.get("response")
                    else None,
                }
            )

        # Session-level metrics
        session_duration = (
            session_traces["timestamp_ms"].max() - session_traces["timestamp_ms"].min()
        )
        total_turns = len(conversation_turns)
        successful_turns = len(session_traces[session_traces["status"] == "OK"])
        avg_turn_duration = session_traces["execution_time_ms"].mean()

        return {
            "session_id": session_id,
            "total_turns": total_turns,
            "successful_turns": successful_turns,
            "session_duration_ms": session_duration,
            "avg_turn_duration_ms": avg_turn_duration,
            "conversation_flow": conversation_turns,
        }


    # Usage
    session_analysis = analyze_session_flow("session-abc-456", "1")
    print(
        f"Session had {session_analysis['total_turns']} turns over {session_analysis['session_duration_ms']}ms"
    )
    ```
  </TabItem>
  <TabItem value="comparative-analysis" label="Comparative Analysis">
    ```python
    def compare_user_segments(experiment_id: str, segment_tag: str = "user_tier"):
        """Compare behavior across different user segments."""

        # Get all traces with the segment tag
        all_traces = mlflow.search_traces(
            experiment_ids=[experiment_id], filter_string=f"tags.{segment_tag} != ''"
        )

        if all_traces.empty:
            return {"error": "No traces found with segment tag"}

        # Group by segment
        segment_stats = {}

        for segment_value in (
            all_traces["tags"]
            .apply(lambda x: x.get(segment_tag) if isinstance(x, dict) else None)
            .unique()
        ):
            if segment_value is None:
                continue

            segment_traces = all_traces[
                all_traces["tags"].apply(
                    lambda x: x.get(segment_tag) == segment_value
                    if isinstance(x, dict)
                    else False
                )
            ]

            if not segment_traces.empty:
                successful_traces = segment_traces[segment_traces["status"] == "OK"]
                segment_stats[segment_value] = {
                    "total_traces": len(segment_traces),
                    "unique_users": segment_traces["tags"]
                    .apply(
                        lambda x: x.get("mlflow.trace.user")
                        if isinstance(x, dict)
                        else None
                    )
                    .nunique(),
                    "avg_latency_ms": successful_traces["execution_time_ms"].mean()
                    if not successful_traces.empty
                    else 0,
                    "error_rate": (
                        (len(segment_traces) - len(successful_traces)) / len(segment_traces)
                    )
                    * 100,
                }

        return segment_stats


    # Usage
    segment_comparison = compare_user_segments("1", "user_tier")
    for segment, stats in segment_comparison.items():
        print(
            f"{segment}: {stats['unique_users']} users, {stats['avg_latency_ms']:.1f}ms avg latency"
        )
    ```
  </TabItem>
</Tabs>

## Advanced User and Session Management

### Session Lifecycle Management

```python
import mlflow
import uuid
from datetime import datetime


class SessionManager:
    """Manage user sessions with automatic context tracking"""

    def __init__(self):
        self.active_sessions = {}

    def start_session(self, user_id: str, session_type: str = "chat") -> str:
        """Start a new session for a user"""
        session_id = f"session-{uuid.uuid4().hex[:8]}"

        session_info = {
            "session_id": session_id,
            "user_id": user_id,
            "session_type": session_type,
            "start_time": datetime.now().isoformat(),
            "turn_count": 0,
        }

        self.active_sessions[session_id] = session_info

        # Log session start
        with mlflow.start_span(name="session_start") as span:
            span.set_attributes(
                {
                    "session_id": session_id,
                    "user_id": user_id,
                    "session_type": session_type,
                }
            )

            mlflow.update_current_trace(
                tags={
                    "mlflow.trace.user": user_id,
                    "mlflow.trace.session": session_id,
                    "session_event": "start",
                    "session_type": session_type,
                }
            )

        return session_id

    def track_interaction(self, session_id: str, interaction_data: dict):
        """Track an interaction within a session"""
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")

        session_info = self.active_sessions[session_id]
        session_info["turn_count"] += 1

        # Standard user and session tracking
        mlflow.update_current_trace(
            tags={
                "mlflow.trace.user": session_info["user_id"],
                "mlflow.trace.session": session_id,
                "turn_number": str(session_info["turn_count"]),
                "session_type": session_info["session_type"],
            }
        )

    def end_session(self, session_id: str):
        """End a session and log summary"""
        if session_id not in self.active_sessions:
            return

        session_info = self.active_sessions[session_id]

        # Log session end
        with mlflow.start_span(name="session_end") as span:
            span.set_attributes(
                {
                    "session_id": session_id,
                    "total_turns": session_info["turn_count"],
                    "session_duration": "calculated_duration",
                }
            )

            mlflow.update_current_trace(
                tags={
                    "mlflow.trace.user": session_info["user_id"],
                    "mlflow.trace.session": session_id,
                    "session_event": "end",
                    "total_turns": str(session_info["turn_count"]),
                }
            )

        # Clean up
        del self.active_sessions[session_id]


# Usage
session_manager = SessionManager()


@mlflow.trace
def handle_chat_with_session(user_id: str, message: str, session_id: str = None):
    """Handle chat with automatic session management"""

    # Start new session if needed
    if not session_id:
        session_id = session_manager.start_session(user_id, "chat")

    # Track this interaction
    session_manager.track_interaction(session_id, {"message": message})

    # Your chat processing logic
    response = process_message(message)

    return {"response": response, "session_id": session_id}
```

## Best Practices

### ID Management

**Consistent Formats**: Use standardized formats for user and session IDs across your application
- User IDs: `user-{uuid}` or `usr_{timestamp}_{hash}`
- Session IDs: `session-{uuid}` or `sess_{user_id}_{timestamp}`

**Persistent Sessions**: Ensure session IDs persist across page reloads or temporary disconnections

**User Anonymization**: Consider using hashed or anonymized user IDs for privacy compliance

### Session Boundaries

**Clear Start/End**: Define explicit rules for when sessions begin and terminate
- Time-based expiration (e.g., 30 minutes of inactivity)
- Explicit user logout or session end
- Context switches (e.g., changing from chat to file upload)

**Context Preservation**: Maintain session context across different parts of your application

### Metadata Enrichment

Add relevant context to enhance analysis capabilities:

```python
# Example of rich user and session context
mlflow.update_current_trace(
    tags={
        # Standard MLflow tags
        "mlflow.trace.user": user_id,
        "mlflow.trace.session": session_id,
        # User context
        "user_tier": "premium",
        "user_region": "us-west",
        "user_signup_date": "2024-01-15",
        # Session context
        "session_type": "support_chat",
        "session_channel": "web_app",
        "session_turn_count": "5",
        # Application context
        "feature_flags": "new_ui=true,beta_model=false",
        "app_version": "2.1.0",
    }
)
```

## Integration with Other Features

User and session tracking enhances other MLflow capabilities:

**Search and Analysis**: Use user and session filters in [trace search](/genai/tracing/search-traces) for targeted analysis

**Monitoring**: Track performance patterns by user cohorts in [production monitoring](/genai/tracing/prod-monitoring)

**Debugging**: Use session context in [debugging workflows](/genai/tracing/observe-with-traces/query-via-sdk) to understand user-specific issues

**Environment Tracking**: Combine with [version and environment tracking](/genai/tracing/track-environments-context) for comprehensive context

## Privacy and Compliance Considerations

### Data Protection

**User Consent**: Ensure appropriate user consent for tracking and analytics

**Data Minimization**: Only collect user and session data necessary for your use case

**Anonymization**: Consider using hashed user IDs rather than personally identifiable information

**Retention Policies**: Implement appropriate data retention and deletion policies

### Security Best Practices

**Access Controls**: Restrict access to user and session data based on roles and responsibilities

**Audit Logging**: Track who accesses user data and when

**Data Encryption**: Ensure user and session data is encrypted in transit and at rest

**Compliance**: Follow relevant regulations (GDPR, CCPA, etc.) for user data handling

## Summary

User and session tracking with MLflow provides powerful capabilities for understanding user behavior, optimizing user experiences, and analyzing conversation flows. Key benefits include:

- **Enhanced Analytics**: Deep insights into user behavior patterns and session dynamics
- **Improved Personalization**: Data-driven improvements to user-specific experiences
- **Quality Monitoring**: Performance tracking across different user segments
- **Debugging Support**: User and session context for faster issue resolution

The combination of standard MLflow tags (`mlflow.trace.user` and `mlflow.trace.session`) with custom context creates a comprehensive foundation for user-centric observability in GenAI applications.

## Next Steps

**[Track Versions & Environments](/genai/tracing/track-environments-context)**: Add deployment and version context to your traces

**[Query Traces via SDK](/genai/tracing/observe-with-traces/query-via-sdk)**: Build custom analytics using user and session data

**[Search Traces](/genai/tracing/search-traces)**: Master advanced filtering techniques for user and session analysis

**[MLflow Tracing UI](/genai/tracing/observe-with-traces/ui)**: Use the web interface for interactive user and session exploration