from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest
import yaml

from mlflow.models.container import _install_model_dependencies_to_env, _validate_dependency_string
from mlflow.utils import env_manager as em


@pytest.fixture
def model_dir_factory(tmp_path: Path):
    def _create(
        dependencies: list[str] | None = None,
        build_dependencies: list[str] | None = None,
    ) -> Path:
        model_path = (
            tmp_path / f"model_{hash((tuple(dependencies or []), tuple(build_dependencies or [])))}"
        )
        model_path.mkdir(exist_ok=True)

        mlmodel = {"flavors": {"python_function": {"env": {"virtualenv": "python_env.yaml"}}}}
        (model_path / "MLmodel").write_text(yaml.safe_dump(mlmodel))

        python_env = {
            "python": "3.12",
            "build_dependencies": build_dependencies or [],
            "dependencies": dependencies or [],
        }
        (model_path / "python_env.yaml").write_text(yaml.safe_dump(python_env))
        (model_path / "requirements.txt").write_text("requests>=2.0\n")

        return model_path

    return _create


@pytest.fixture
def mock_subprocess_run():
    calls: list[list[str]] = []

    def _run(cmd: list[str], **kwargs) -> MagicMock:
        calls.append(cmd)
        result = MagicMock()
        result.returncode = 0
        return result

    with patch("mlflow.models.container.subprocess.run", side_effect=_run):
        yield calls


MALICIOUS_DEPENDENCIES = [
    "numpy; whoami",
    "numpy && id",
    "numpy || true",
    "numpy | cat /etc/passwd",
    "numpy > /tmp/output",
    "numpy < /dev/null",
    "$(id)",
    "`id`",
    "numpy\nmalicious",
    "numpy$HOME",
    "numpy${PATH}",
    "numpy'injection",
    'numpy"injection',
    "numpy\\injection",
    "numpy()",
    "numpy{}",
]

VALID_DEPENDENCIES = [
    "numpy",
    "numpy==1.24.0",
    "numpy>=1.20,<2.0",
    "scikit-learn",
    "scikit_learn",
    "tensorflow-cpu",
    "package[extra]",
    "package[extra1,extra2]",
    "mlflow>=2.0.0",
    "package==1.0.0",
    "package>=1.0",
    "package<=2.0",
    "package!=1.5",
    "package~=1.0",
    "package>=1.0,<2.0,!=1.5",
]


@pytest.mark.parametrize("malicious_dep", MALICIOUS_DEPENDENCIES)
def test_malicious_dependency_rejected(model_dir_factory, malicious_dep: str):
    model_path = model_dir_factory(dependencies=[malicious_dep])
    with pytest.raises(ValueError, match="Invalid dependency string"):
        _install_model_dependencies_to_env(str(model_path), em.LOCAL)


@pytest.mark.parametrize("malicious_dep", MALICIOUS_DEPENDENCIES)
def test_malicious_build_dependency_rejected(model_dir_factory, malicious_dep: str):
    model_path = model_dir_factory(build_dependencies=[malicious_dep])
    with pytest.raises(ValueError, match="Invalid dependency string"):
        _install_model_dependencies_to_env(str(model_path), em.LOCAL)


@pytest.mark.parametrize("valid_dep", VALID_DEPENDENCIES)
def test_valid_dependency_accepted(model_dir_factory, mock_subprocess_run, valid_dep: str):
    model_path = model_dir_factory(dependencies=[valid_dep])
    _install_model_dependencies_to_env(str(model_path), em.LOCAL)

    assert len(mock_subprocess_run) == 1
    assert valid_dep in mock_subprocess_run[0]


def test_valid_model_uses_subprocess_list_not_shell(model_dir_factory, mock_subprocess_run):
    model_path = model_dir_factory(
        build_dependencies=["pip==23.0", "setuptools>=65.0", "wheel"],
        dependencies=["-r requirements.txt"],
    )
    _install_model_dependencies_to_env(str(model_path), em.LOCAL)

    assert len(mock_subprocess_run) == 1
    cmd = mock_subprocess_run[0]
    assert isinstance(cmd, list)
    assert cmd[:4] == ["python", "-m", "pip", "install"]
    assert "pip==23.0" in cmd
    assert "setuptools>=65.0" in cmd
    assert "wheel" in cmd
    assert "-r" in cmd


def test_requirements_txt_path_expanded(model_dir_factory, mock_subprocess_run):
    model_path = model_dir_factory(dependencies=["-r requirements.txt"])
    _install_model_dependencies_to_env(str(model_path), em.LOCAL)

    cmd = mock_subprocess_run[0]
    r_index = cmd.index("-r")
    requirements_path = cmd[r_index + 1]
    assert requirements_path.endswith("requirements.txt")
    assert str(model_path) in requirements_path


@pytest.mark.parametrize(
    "dep",
    [
        "numpy; rm -rf /",
        "numpy | cat",
        "numpy && id",
        "numpy$HOME",
        "`whoami`",
        "numpy > /tmp/out",
        "numpy < /etc/passwd",
        "numpy\nmalicious",
    ],
)
def test_validate_dependency_string_rejects_dangerous(dep: str):
    with pytest.raises(ValueError, match="Invalid dependency string"):
        _validate_dependency_string(dep)


@pytest.mark.parametrize(
    "dep",
    [
        "numpy",
        "numpy==1.24.0",
        "scikit-learn>=1.0",
        "package>=1.0,<2.0",
        "package<=2.0",
        "package<2.0",
        "package>1.0",
        "numpy>=1.0,<2.0,!=1.5",
    ],
)
def test_validate_dependency_string_accepts_valid(dep: str):
    _validate_dependency_string(dep)
