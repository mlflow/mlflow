// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package client

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MlflowServiceClient is the client API for MlflowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MlflowServiceClient interface {
	// Get metadata for an experiment.
	//
	// This endpoint will return deleted experiments, but prefers the active experiment
	// if an active and deleted experiment share the same name. If multiple deleted
	// experiments share the same name, the API will return one of them.
	//
	// Throws ``RESOURCE_DOES_NOT_EXIST`` if no experiment with the specified name exists.
	//
	GetExperimentByName(ctx context.Context, in *GetExperimentByName, opts ...grpc.CallOption) (*GetExperimentByName_Response, error)
	// Create an experiment with a name. Returns the ID of the newly created experiment.
	// Validates that another experiment with the same name does not already exist and fails
	// if another experiment with the same name already exists.
	//
	//
	// Throws ``RESOURCE_ALREADY_EXISTS`` if a experiment with the given name exists.
	//
	CreateExperiment(ctx context.Context, in *CreateExperiment, opts ...grpc.CallOption) (*CreateExperiment_Response, error)
	// Get a list of all experiments.
	//
	ListExperiments(ctx context.Context, in *ListExperiments, opts ...grpc.CallOption) (*ListExperiments_Response, error)
	// Get metadata for an experiment. This method works on deleted experiments.
	GetExperiment(ctx context.Context, in *GetExperiment, opts ...grpc.CallOption) (*GetExperiment_Response, error)
	// Mark an experiment and associated metadata, runs, metrics, params, and tags for deletion.
	// If the experiment uses FileStore, artifacts associated with experiment are also deleted.
	//
	DeleteExperiment(ctx context.Context, in *DeleteExperiment, opts ...grpc.CallOption) (*DeleteExperiment_Response, error)
	// Restore an experiment marked for deletion. This also restores
	// associated metadata, runs, metrics, params, and tags. If experiment uses FileStore, underlying
	// artifacts associated with experiment are also restored.
	//
	// Throws ``RESOURCE_DOES_NOT_EXIST`` if experiment was never created or was permanently deleted.
	//
	RestoreExperiment(ctx context.Context, in *RestoreExperiment, opts ...grpc.CallOption) (*RestoreExperiment_Response, error)
	// Update experiment metadata.
	//
	UpdateExperiment(ctx context.Context, in *UpdateExperiment, opts ...grpc.CallOption) (*UpdateExperiment_Response, error)
	// Create a new run within an experiment. A run is usually a single execution of a
	// machine learning or data ETL pipeline. MLflow uses runs to track :ref:`mlflowParam`,
	// :ref:`mlflowMetric`, and :ref:`mlflowRunTag` associated with a single execution.
	//
	CreateRun(ctx context.Context, in *CreateRun, opts ...grpc.CallOption) (*CreateRun_Response, error)
	// Update run metadata.
	//
	UpdateRun(ctx context.Context, in *UpdateRun, opts ...grpc.CallOption) (*UpdateRun_Response, error)
	// Mark a run for deletion.
	DeleteRun(ctx context.Context, in *DeleteRun, opts ...grpc.CallOption) (*DeleteRun_Response, error)
	// Restore a deleted run.
	RestoreRun(ctx context.Context, in *RestoreRun, opts ...grpc.CallOption) (*RestoreRun_Response, error)
	// Log a metric for a run. A metric is a key-value pair (string key, float value) with an
	// associated timestamp. Examples include the various metrics that represent ML model accuracy.
	// A metric can be logged multiple times.
	//
	LogMetric(ctx context.Context, in *LogMetric, opts ...grpc.CallOption) (*LogMetric_Response, error)
	// Log a param used for a run. A param is a key-value pair (string key,
	// string value). Examples include hyperparameters used for ML model training and
	// constant dates and values used in an ETL pipeline. A param can be logged only once for a run.
	//
	LogParam(ctx context.Context, in *LogParam, opts ...grpc.CallOption) (*LogParam_Response, error)
	// Set a tag on an experiment. Experiment tags are metadata that can be updated.
	//
	SetExperimentTag(ctx context.Context, in *SetExperimentTag, opts ...grpc.CallOption) (*SetExperimentTag_Response, error)
	// Set a tag on a run. Tags are run metadata that can be updated during a run and after
	// a run completes.
	//
	SetTag(ctx context.Context, in *SetTag, opts ...grpc.CallOption) (*SetTag_Response, error)
	// Delete a tag on a run. Tags are run metadata that can be updated during a run and after
	// a run completes.
	//
	DeleteTag(ctx context.Context, in *DeleteTag, opts ...grpc.CallOption) (*DeleteTag_Response, error)
	// Get metadata, metrics, params, and tags for a run. In the case where multiple metrics
	// with the same key are logged for a run, return only the value with the latest timestamp.
	// If there are multiple values with the latest timestamp, return the maximum of these values.
	GetRun(ctx context.Context, in *GetRun, opts ...grpc.CallOption) (*GetRun_Response, error)
	// Search for runs that satisfy expressions. Search expressions can use :ref:`mlflowMetric` and
	// :ref:`mlflowParam` keys.
	//
	SearchRuns(ctx context.Context, in *SearchRuns, opts ...grpc.CallOption) (*SearchRuns_Response, error)
	// List artifacts for a run. Takes an optional ``artifact_path`` prefix which if specified,
	// the response contains only artifacts with the specified prefix.
	//
	ListArtifacts(ctx context.Context, in *ListArtifacts, opts ...grpc.CallOption) (*ListArtifacts_Response, error)
	// Get a list of all values for the specified metric for a given run.
	//
	GetMetricHistory(ctx context.Context, in *GetMetricHistory, opts ...grpc.CallOption) (*GetMetricHistory_Response, error)
	// Log a batch of metrics, params, and tags for a run.
	// If any data failed to be persisted, the server will respond with an error (non-200 status code).
	// In case of error (due to internal server error or an invalid request), partial data may
	// be written.
	//
	// You can write metrics, params, and tags in interleaving fashion, but within a given entity
	// type are guaranteed to follow the order specified in the request body. That is, for an API
	// request like
	//
	// .. code-block:: json
	//
	//   {
	//      "run_id": "2a14ed5c6a87499199e0106c3501eab8",
	//      "metrics": [
	//        {"key": "mae", "value": 2.5, "timestamp": 1552550804},
	//        {"key": "rmse", "value": 2.7, "timestamp": 1552550804},
	//      ],
	//      "params": [
	//        {"key": "model_class", "value": "LogisticRegression"},
	//      ]
	//   }
	//
	// the server is guaranteed to write metric "rmse" after "mae", though it may write param
	// "model_class" before both metrics, after "mae", or after both metrics.
	//
	// The overwrite behavior for metrics, params, and tags is as follows:
	//
	// - Metrics: metric values are never overwritten. Logging a metric (key, value, timestamp) appends to the set of values for the metric with the provided key.
	//
	// - Tags: tag values can be overwritten by successive writes to the same tag key. That is, if multiple tag values with the same key are provided in the same API request, the last-provided tag value is written. Logging the same tag (key, value) is permitted - that is, logging a tag is idempotent.
	//
	// - Params: once written, param values cannot be changed (attempting to overwrite a param value will result in an error). However, logging the same param (key, value) is permitted - that is, logging a param is idempotent.
	//
	// Request Limits
	// --------------
	// A single JSON-serialized API request may be up to 1 MB in size and contain:
	//
	// - No more than 1000 metrics, params, and tags in total
	// - Up to 1000 metrics
	// - Up to 100 params
	// - Up to 100 tags
	//
	// For example, a valid request might contain 900 metrics, 50 params, and 50 tags, but logging
	// 900 metrics, 50 params, and 51 tags is invalid. The following limits also apply
	// to metric, param, and tag keys and values:
	//
	// - Metric, param, and tag keys can be up to 250 characters in length
	// - Param and tag values can be up to 250 characters in length
	//
	LogBatch(ctx context.Context, in *LogBatch, opts ...grpc.CallOption) (*LogBatch_Response, error)
	// .. note::
	//     Experimental: This API may change or be removed in a future release without warning.
	LogModel(ctx context.Context, in *LogModel, opts ...grpc.CallOption) (*LogModel_Response, error)
}

type mlflowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMlflowServiceClient(cc grpc.ClientConnInterface) MlflowServiceClient {
	return &mlflowServiceClient{cc}
}

func (c *mlflowServiceClient) GetExperimentByName(ctx context.Context, in *GetExperimentByName, opts ...grpc.CallOption) (*GetExperimentByName_Response, error) {
	out := new(GetExperimentByName_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/getExperimentByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) CreateExperiment(ctx context.Context, in *CreateExperiment, opts ...grpc.CallOption) (*CreateExperiment_Response, error) {
	out := new(CreateExperiment_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/createExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) ListExperiments(ctx context.Context, in *ListExperiments, opts ...grpc.CallOption) (*ListExperiments_Response, error) {
	out := new(ListExperiments_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/listExperiments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) GetExperiment(ctx context.Context, in *GetExperiment, opts ...grpc.CallOption) (*GetExperiment_Response, error) {
	out := new(GetExperiment_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/getExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) DeleteExperiment(ctx context.Context, in *DeleteExperiment, opts ...grpc.CallOption) (*DeleteExperiment_Response, error) {
	out := new(DeleteExperiment_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/deleteExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) RestoreExperiment(ctx context.Context, in *RestoreExperiment, opts ...grpc.CallOption) (*RestoreExperiment_Response, error) {
	out := new(RestoreExperiment_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/restoreExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) UpdateExperiment(ctx context.Context, in *UpdateExperiment, opts ...grpc.CallOption) (*UpdateExperiment_Response, error) {
	out := new(UpdateExperiment_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/updateExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) CreateRun(ctx context.Context, in *CreateRun, opts ...grpc.CallOption) (*CreateRun_Response, error) {
	out := new(CreateRun_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/createRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) UpdateRun(ctx context.Context, in *UpdateRun, opts ...grpc.CallOption) (*UpdateRun_Response, error) {
	out := new(UpdateRun_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/updateRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) DeleteRun(ctx context.Context, in *DeleteRun, opts ...grpc.CallOption) (*DeleteRun_Response, error) {
	out := new(DeleteRun_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/deleteRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) RestoreRun(ctx context.Context, in *RestoreRun, opts ...grpc.CallOption) (*RestoreRun_Response, error) {
	out := new(RestoreRun_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/restoreRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) LogMetric(ctx context.Context, in *LogMetric, opts ...grpc.CallOption) (*LogMetric_Response, error) {
	out := new(LogMetric_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/logMetric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) LogParam(ctx context.Context, in *LogParam, opts ...grpc.CallOption) (*LogParam_Response, error) {
	out := new(LogParam_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/logParam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) SetExperimentTag(ctx context.Context, in *SetExperimentTag, opts ...grpc.CallOption) (*SetExperimentTag_Response, error) {
	out := new(SetExperimentTag_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/setExperimentTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) SetTag(ctx context.Context, in *SetTag, opts ...grpc.CallOption) (*SetTag_Response, error) {
	out := new(SetTag_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/setTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) DeleteTag(ctx context.Context, in *DeleteTag, opts ...grpc.CallOption) (*DeleteTag_Response, error) {
	out := new(DeleteTag_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/deleteTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) GetRun(ctx context.Context, in *GetRun, opts ...grpc.CallOption) (*GetRun_Response, error) {
	out := new(GetRun_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/getRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) SearchRuns(ctx context.Context, in *SearchRuns, opts ...grpc.CallOption) (*SearchRuns_Response, error) {
	out := new(SearchRuns_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/searchRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) ListArtifacts(ctx context.Context, in *ListArtifacts, opts ...grpc.CallOption) (*ListArtifacts_Response, error) {
	out := new(ListArtifacts_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/listArtifacts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) GetMetricHistory(ctx context.Context, in *GetMetricHistory, opts ...grpc.CallOption) (*GetMetricHistory_Response, error) {
	out := new(GetMetricHistory_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/getMetricHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) LogBatch(ctx context.Context, in *LogBatch, opts ...grpc.CallOption) (*LogBatch_Response, error) {
	out := new(LogBatch_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/logBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlflowServiceClient) LogModel(ctx context.Context, in *LogModel, opts ...grpc.CallOption) (*LogModel_Response, error) {
	out := new(LogModel_Response)
	err := c.cc.Invoke(ctx, "/mlflow.MlflowService/logModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MlflowServiceServer is the server API for MlflowService service.
// All implementations must embed UnimplementedMlflowServiceServer
// for forward compatibility
type MlflowServiceServer interface {
	// Get metadata for an experiment.
	//
	// This endpoint will return deleted experiments, but prefers the active experiment
	// if an active and deleted experiment share the same name. If multiple deleted
	// experiments share the same name, the API will return one of them.
	//
	// Throws ``RESOURCE_DOES_NOT_EXIST`` if no experiment with the specified name exists.
	//
	GetExperimentByName(context.Context, *GetExperimentByName) (*GetExperimentByName_Response, error)
	// Create an experiment with a name. Returns the ID of the newly created experiment.
	// Validates that another experiment with the same name does not already exist and fails
	// if another experiment with the same name already exists.
	//
	//
	// Throws ``RESOURCE_ALREADY_EXISTS`` if a experiment with the given name exists.
	//
	CreateExperiment(context.Context, *CreateExperiment) (*CreateExperiment_Response, error)
	// Get a list of all experiments.
	//
	ListExperiments(context.Context, *ListExperiments) (*ListExperiments_Response, error)
	// Get metadata for an experiment. This method works on deleted experiments.
	GetExperiment(context.Context, *GetExperiment) (*GetExperiment_Response, error)
	// Mark an experiment and associated metadata, runs, metrics, params, and tags for deletion.
	// If the experiment uses FileStore, artifacts associated with experiment are also deleted.
	//
	DeleteExperiment(context.Context, *DeleteExperiment) (*DeleteExperiment_Response, error)
	// Restore an experiment marked for deletion. This also restores
	// associated metadata, runs, metrics, params, and tags. If experiment uses FileStore, underlying
	// artifacts associated with experiment are also restored.
	//
	// Throws ``RESOURCE_DOES_NOT_EXIST`` if experiment was never created or was permanently deleted.
	//
	RestoreExperiment(context.Context, *RestoreExperiment) (*RestoreExperiment_Response, error)
	// Update experiment metadata.
	//
	UpdateExperiment(context.Context, *UpdateExperiment) (*UpdateExperiment_Response, error)
	// Create a new run within an experiment. A run is usually a single execution of a
	// machine learning or data ETL pipeline. MLflow uses runs to track :ref:`mlflowParam`,
	// :ref:`mlflowMetric`, and :ref:`mlflowRunTag` associated with a single execution.
	//
	CreateRun(context.Context, *CreateRun) (*CreateRun_Response, error)
	// Update run metadata.
	//
	UpdateRun(context.Context, *UpdateRun) (*UpdateRun_Response, error)
	// Mark a run for deletion.
	DeleteRun(context.Context, *DeleteRun) (*DeleteRun_Response, error)
	// Restore a deleted run.
	RestoreRun(context.Context, *RestoreRun) (*RestoreRun_Response, error)
	// Log a metric for a run. A metric is a key-value pair (string key, float value) with an
	// associated timestamp. Examples include the various metrics that represent ML model accuracy.
	// A metric can be logged multiple times.
	//
	LogMetric(context.Context, *LogMetric) (*LogMetric_Response, error)
	// Log a param used for a run. A param is a key-value pair (string key,
	// string value). Examples include hyperparameters used for ML model training and
	// constant dates and values used in an ETL pipeline. A param can be logged only once for a run.
	//
	LogParam(context.Context, *LogParam) (*LogParam_Response, error)
	// Set a tag on an experiment. Experiment tags are metadata that can be updated.
	//
	SetExperimentTag(context.Context, *SetExperimentTag) (*SetExperimentTag_Response, error)
	// Set a tag on a run. Tags are run metadata that can be updated during a run and after
	// a run completes.
	//
	SetTag(context.Context, *SetTag) (*SetTag_Response, error)
	// Delete a tag on a run. Tags are run metadata that can be updated during a run and after
	// a run completes.
	//
	DeleteTag(context.Context, *DeleteTag) (*DeleteTag_Response, error)
	// Get metadata, metrics, params, and tags for a run. In the case where multiple metrics
	// with the same key are logged for a run, return only the value with the latest timestamp.
	// If there are multiple values with the latest timestamp, return the maximum of these values.
	GetRun(context.Context, *GetRun) (*GetRun_Response, error)
	// Search for runs that satisfy expressions. Search expressions can use :ref:`mlflowMetric` and
	// :ref:`mlflowParam` keys.
	//
	SearchRuns(context.Context, *SearchRuns) (*SearchRuns_Response, error)
	// List artifacts for a run. Takes an optional ``artifact_path`` prefix which if specified,
	// the response contains only artifacts with the specified prefix.
	//
	ListArtifacts(context.Context, *ListArtifacts) (*ListArtifacts_Response, error)
	// Get a list of all values for the specified metric for a given run.
	//
	GetMetricHistory(context.Context, *GetMetricHistory) (*GetMetricHistory_Response, error)
	// Log a batch of metrics, params, and tags for a run.
	// If any data failed to be persisted, the server will respond with an error (non-200 status code).
	// In case of error (due to internal server error or an invalid request), partial data may
	// be written.
	//
	// You can write metrics, params, and tags in interleaving fashion, but within a given entity
	// type are guaranteed to follow the order specified in the request body. That is, for an API
	// request like
	//
	// .. code-block:: json
	//
	//   {
	//      "run_id": "2a14ed5c6a87499199e0106c3501eab8",
	//      "metrics": [
	//        {"key": "mae", "value": 2.5, "timestamp": 1552550804},
	//        {"key": "rmse", "value": 2.7, "timestamp": 1552550804},
	//      ],
	//      "params": [
	//        {"key": "model_class", "value": "LogisticRegression"},
	//      ]
	//   }
	//
	// the server is guaranteed to write metric "rmse" after "mae", though it may write param
	// "model_class" before both metrics, after "mae", or after both metrics.
	//
	// The overwrite behavior for metrics, params, and tags is as follows:
	//
	// - Metrics: metric values are never overwritten. Logging a metric (key, value, timestamp) appends to the set of values for the metric with the provided key.
	//
	// - Tags: tag values can be overwritten by successive writes to the same tag key. That is, if multiple tag values with the same key are provided in the same API request, the last-provided tag value is written. Logging the same tag (key, value) is permitted - that is, logging a tag is idempotent.
	//
	// - Params: once written, param values cannot be changed (attempting to overwrite a param value will result in an error). However, logging the same param (key, value) is permitted - that is, logging a param is idempotent.
	//
	// Request Limits
	// --------------
	// A single JSON-serialized API request may be up to 1 MB in size and contain:
	//
	// - No more than 1000 metrics, params, and tags in total
	// - Up to 1000 metrics
	// - Up to 100 params
	// - Up to 100 tags
	//
	// For example, a valid request might contain 900 metrics, 50 params, and 50 tags, but logging
	// 900 metrics, 50 params, and 51 tags is invalid. The following limits also apply
	// to metric, param, and tag keys and values:
	//
	// - Metric, param, and tag keys can be up to 250 characters in length
	// - Param and tag values can be up to 250 characters in length
	//
	LogBatch(context.Context, *LogBatch) (*LogBatch_Response, error)
	// .. note::
	//     Experimental: This API may change or be removed in a future release without warning.
	LogModel(context.Context, *LogModel) (*LogModel_Response, error)
	mustEmbedUnimplementedMlflowServiceServer()
}

// UnimplementedMlflowServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMlflowServiceServer struct {
}

func (UnimplementedMlflowServiceServer) GetExperimentByName(context.Context, *GetExperimentByName) (*GetExperimentByName_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExperimentByName not implemented")
}
func (UnimplementedMlflowServiceServer) CreateExperiment(context.Context, *CreateExperiment) (*CreateExperiment_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExperiment not implemented")
}
func (UnimplementedMlflowServiceServer) ListExperiments(context.Context, *ListExperiments) (*ListExperiments_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExperiments not implemented")
}
func (UnimplementedMlflowServiceServer) GetExperiment(context.Context, *GetExperiment) (*GetExperiment_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExperiment not implemented")
}
func (UnimplementedMlflowServiceServer) DeleteExperiment(context.Context, *DeleteExperiment) (*DeleteExperiment_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExperiment not implemented")
}
func (UnimplementedMlflowServiceServer) RestoreExperiment(context.Context, *RestoreExperiment) (*RestoreExperiment_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreExperiment not implemented")
}
func (UnimplementedMlflowServiceServer) UpdateExperiment(context.Context, *UpdateExperiment) (*UpdateExperiment_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExperiment not implemented")
}
func (UnimplementedMlflowServiceServer) CreateRun(context.Context, *CreateRun) (*CreateRun_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRun not implemented")
}
func (UnimplementedMlflowServiceServer) UpdateRun(context.Context, *UpdateRun) (*UpdateRun_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRun not implemented")
}
func (UnimplementedMlflowServiceServer) DeleteRun(context.Context, *DeleteRun) (*DeleteRun_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRun not implemented")
}
func (UnimplementedMlflowServiceServer) RestoreRun(context.Context, *RestoreRun) (*RestoreRun_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreRun not implemented")
}
func (UnimplementedMlflowServiceServer) LogMetric(context.Context, *LogMetric) (*LogMetric_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogMetric not implemented")
}
func (UnimplementedMlflowServiceServer) LogParam(context.Context, *LogParam) (*LogParam_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogParam not implemented")
}
func (UnimplementedMlflowServiceServer) SetExperimentTag(context.Context, *SetExperimentTag) (*SetExperimentTag_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExperimentTag not implemented")
}
func (UnimplementedMlflowServiceServer) SetTag(context.Context, *SetTag) (*SetTag_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTag not implemented")
}
func (UnimplementedMlflowServiceServer) DeleteTag(context.Context, *DeleteTag) (*DeleteTag_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTag not implemented")
}
func (UnimplementedMlflowServiceServer) GetRun(context.Context, *GetRun) (*GetRun_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRun not implemented")
}
func (UnimplementedMlflowServiceServer) SearchRuns(context.Context, *SearchRuns) (*SearchRuns_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchRuns not implemented")
}
func (UnimplementedMlflowServiceServer) ListArtifacts(context.Context, *ListArtifacts) (*ListArtifacts_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArtifacts not implemented")
}
func (UnimplementedMlflowServiceServer) GetMetricHistory(context.Context, *GetMetricHistory) (*GetMetricHistory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetricHistory not implemented")
}
func (UnimplementedMlflowServiceServer) LogBatch(context.Context, *LogBatch) (*LogBatch_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogBatch not implemented")
}
func (UnimplementedMlflowServiceServer) LogModel(context.Context, *LogModel) (*LogModel_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogModel not implemented")
}
func (UnimplementedMlflowServiceServer) mustEmbedUnimplementedMlflowServiceServer() {}

// UnsafeMlflowServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MlflowServiceServer will
// result in compilation errors.
type UnsafeMlflowServiceServer interface {
	mustEmbedUnimplementedMlflowServiceServer()
}

func RegisterMlflowServiceServer(s grpc.ServiceRegistrar, srv MlflowServiceServer) {
	s.RegisterService(&MlflowService_ServiceDesc, srv)
}

func _MlflowService_GetExperimentByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExperimentByName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).GetExperimentByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/getExperimentByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).GetExperimentByName(ctx, req.(*GetExperimentByName))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_CreateExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExperiment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).CreateExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/createExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).CreateExperiment(ctx, req.(*CreateExperiment))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_ListExperiments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExperiments)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).ListExperiments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/listExperiments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).ListExperiments(ctx, req.(*ListExperiments))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_GetExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExperiment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).GetExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/getExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).GetExperiment(ctx, req.(*GetExperiment))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_DeleteExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExperiment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).DeleteExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/deleteExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).DeleteExperiment(ctx, req.(*DeleteExperiment))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_RestoreExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreExperiment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).RestoreExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/restoreExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).RestoreExperiment(ctx, req.(*RestoreExperiment))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_UpdateExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExperiment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).UpdateExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/updateExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).UpdateExperiment(ctx, req.(*UpdateExperiment))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_CreateRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRun)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).CreateRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/createRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).CreateRun(ctx, req.(*CreateRun))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_UpdateRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRun)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).UpdateRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/updateRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).UpdateRun(ctx, req.(*UpdateRun))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_DeleteRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRun)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).DeleteRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/deleteRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).DeleteRun(ctx, req.(*DeleteRun))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_RestoreRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreRun)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).RestoreRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/restoreRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).RestoreRun(ctx, req.(*RestoreRun))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_LogMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogMetric)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).LogMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/logMetric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).LogMetric(ctx, req.(*LogMetric))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_LogParam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogParam)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).LogParam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/logParam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).LogParam(ctx, req.(*LogParam))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_SetExperimentTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetExperimentTag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).SetExperimentTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/setExperimentTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).SetExperimentTag(ctx, req.(*SetExperimentTag))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_SetTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).SetTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/setTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).SetTag(ctx, req.(*SetTag))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_DeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).DeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/deleteTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).DeleteTag(ctx, req.(*DeleteTag))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_GetRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRun)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).GetRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/getRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).GetRun(ctx, req.(*GetRun))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_SearchRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRuns)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).SearchRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/searchRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).SearchRuns(ctx, req.(*SearchRuns))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_ListArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArtifacts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).ListArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/listArtifacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).ListArtifacts(ctx, req.(*ListArtifacts))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_GetMetricHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricHistory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).GetMetricHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/getMetricHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).GetMetricHistory(ctx, req.(*GetMetricHistory))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_LogBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).LogBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/logBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).LogBatch(ctx, req.(*LogBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlflowService_LogModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlflowServiceServer).LogModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlflow.MlflowService/logModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlflowServiceServer).LogModel(ctx, req.(*LogModel))
	}
	return interceptor(ctx, in, info, handler)
}

// MlflowService_ServiceDesc is the grpc.ServiceDesc for MlflowService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MlflowService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mlflow.MlflowService",
	HandlerType: (*MlflowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getExperimentByName",
			Handler:    _MlflowService_GetExperimentByName_Handler,
		},
		{
			MethodName: "createExperiment",
			Handler:    _MlflowService_CreateExperiment_Handler,
		},
		{
			MethodName: "listExperiments",
			Handler:    _MlflowService_ListExperiments_Handler,
		},
		{
			MethodName: "getExperiment",
			Handler:    _MlflowService_GetExperiment_Handler,
		},
		{
			MethodName: "deleteExperiment",
			Handler:    _MlflowService_DeleteExperiment_Handler,
		},
		{
			MethodName: "restoreExperiment",
			Handler:    _MlflowService_RestoreExperiment_Handler,
		},
		{
			MethodName: "updateExperiment",
			Handler:    _MlflowService_UpdateExperiment_Handler,
		},
		{
			MethodName: "createRun",
			Handler:    _MlflowService_CreateRun_Handler,
		},
		{
			MethodName: "updateRun",
			Handler:    _MlflowService_UpdateRun_Handler,
		},
		{
			MethodName: "deleteRun",
			Handler:    _MlflowService_DeleteRun_Handler,
		},
		{
			MethodName: "restoreRun",
			Handler:    _MlflowService_RestoreRun_Handler,
		},
		{
			MethodName: "logMetric",
			Handler:    _MlflowService_LogMetric_Handler,
		},
		{
			MethodName: "logParam",
			Handler:    _MlflowService_LogParam_Handler,
		},
		{
			MethodName: "setExperimentTag",
			Handler:    _MlflowService_SetExperimentTag_Handler,
		},
		{
			MethodName: "setTag",
			Handler:    _MlflowService_SetTag_Handler,
		},
		{
			MethodName: "deleteTag",
			Handler:    _MlflowService_DeleteTag_Handler,
		},
		{
			MethodName: "getRun",
			Handler:    _MlflowService_GetRun_Handler,
		},
		{
			MethodName: "searchRuns",
			Handler:    _MlflowService_SearchRuns_Handler,
		},
		{
			MethodName: "listArtifacts",
			Handler:    _MlflowService_ListArtifacts_Handler,
		},
		{
			MethodName: "getMetricHistory",
			Handler:    _MlflowService_GetMetricHistory_Handler,
		},
		{
			MethodName: "logBatch",
			Handler:    _MlflowService_LogBatch_Handler,
		},
		{
			MethodName: "logModel",
			Handler:    _MlflowService_LogModel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
