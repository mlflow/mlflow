/**
 * TelemetryLogger client
 *
 * Wrapper for interacting with the TelemetryLogger SharedWorker.
 * Provides a simple API for logging telemetry events.
 */
import type { TelemetryRecord } from './worker/types';
import { isDesignSystemEvent, TELEMETRY_ENABLED_STORAGE_KEY, TELEMETRY_ENABLED_STORAGE_VERSION } from './utils';
import { WorkerToClientMessageType, ClientToWorkerMessageType } from './worker/types';
import { getLocalStorageItem } from '../shared/web-shared/hooks/useLocalStorage';

const LOCAL_STORAGE_INSTALLATION_ID_KEY = 'mlflow-telemetry-installation-id';

class TelemetryClient {
  private installationId: string = this.getInstallationId();
  private port: MessagePort | null = null;
  private ready: Promise<boolean> = this.initWorker();

  private getInstallationId(): string {
    // not using `getLocalStorageItem` because this key is not used in react
    const localStorageInstallationId = localStorage.getItem(LOCAL_STORAGE_INSTALLATION_ID_KEY);

    if (!localStorageInstallationId) {
      const installationId = crypto.randomUUID();
      localStorage.setItem(LOCAL_STORAGE_INSTALLATION_ID_KEY, installationId);
      return installationId;
    } else {
      return localStorageInstallationId;
    }
  }

  private getTelemetryEnabled(): boolean {
    // need to use the function from web-shared because this key is
    // changed using `useLocalStorage` inside the settings page, which
    // appends the version to the key.
    const telemetryEnabled = getLocalStorageItem(
      TELEMETRY_ENABLED_STORAGE_KEY,
      TELEMETRY_ENABLED_STORAGE_VERSION,
      // default to true as the feature is opt-out
      true,
    );

    return telemetryEnabled;
  }

  private initWorker(): Promise<boolean> {
    return new Promise((resolve) => {
      try {
        // if telemetry is disabled, we don't need to initialize the worker at all
        if (!this.getTelemetryEnabled()) {
          resolve(false);
          return;
        }

        // Create SharedWorker instance
        this.port = new SharedWorker(new URL('./worker/TelemetryLogger.worker.ts', import.meta.url), {
          name: 'telemetry-worker',
        }).port;

        if (!this.port) {
          resolve(false);
          return;
        }

        const handleReadyMessage = (event: MessageEvent): void => {
          if (event.data.type === WorkerToClientMessageType.READY) {
            resolve(true);
          }
        };

        // Listen for the "READY" message from worker
        this.port.onmessage = handleReadyMessage;
      } catch (error) {
        console.error('[TelemetryLogger] Failed to initialize SharedWorker:', error);
        resolve(false);
      }
    });
  }

  /**
   * Log a telemetry event
   */
  public async logEvent(record: any): Promise<void> {
    const isReady = await this.ready;
    if (!isReady || !this.port) {
      return;
    }

    if (!isDesignSystemEvent(record)) {
      return;
    }

    // drop view events to reduce noise
    if (record.eventType === 'onView') {
      return;
    }

    // session_id is generated by the worker
    const payload: Omit<TelemetryRecord, 'session_id'> = {
      installation_id: this.installationId,
      event_name: 'ui_event',
      // convert from ms to ns
      timestamp_ns: Date.now() * 1e6,
      params: {
        componentId: record.componentId,
        componentViewId: record.componentViewId,
        componentType: record.componentType,
        componentSubType: record.componentSubType,
        eventType: record.eventType,
      },
    };

    this.port?.postMessage({
      type: ClientToWorkerMessageType.LOG_EVENT,
      payload,
    });
  }

  public shutdown(): void {
    this.port?.postMessage({
      type: ClientToWorkerMessageType.SHUTDOWN,
    });
    this.port = null;
  }

  // used for restarting the worker after a shutdown
  public start(): void {
    this.ready = this.initWorker();
  }
}

// Singleton instance
export const telemetryClient: TelemetryClient = new TelemetryClient();
