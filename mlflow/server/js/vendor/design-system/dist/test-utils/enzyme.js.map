{"version":3,"file":"enzyme.js","sources":["../../src/test-utils/enzyme/utils.ts","../../src/test-utils/enzyme/selectEvent.ts","../../src/test-utils/enzyme/table.ts","../../src/test-utils/enzyme/index.ts"],"sourcesContent":["// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\nimport { act } from 'react-dom/test-utils';\n\ninterface QueryOptions {\n  /** Whether to trim the whitespace from DOM text using `String.prototype.trim` */\n  trim?: boolean;\n}\n\n/**\n * Finds a single element that contains the specified text in the wrapper. If\n * there are 0 or more than 1 element that contains the specified text, an error\n * is thrown. Returns the element in an enzyme wrapper.\n */\nexport function findByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  queryOptions?: QueryOptions,\n) {\n  const newWrappers = findAllByText<P, S, C>(wrapper, text, queryOptions);\n  if (newWrappers.length !== 1) {\n    throw new Error(\n      `Expected to find 1 node but found ${newWrappers.length} nodes for text \"${text}\".\\n${wrapper.debug()}`,\n    );\n  }\n  return newWrappers[0];\n}\n\n/**\n * Finds all elements that contain the specified text. To avoid duplicate results,\n * only the parents of text nodes are returned.\n */\nexport function findAllByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  { trim = false }: QueryOptions = {},\n) {\n  const textNodes = wrapper.findWhere((n) => {\n    if (typeof n.type() !== 'string' || n.getDOMNode().children.length !== 0) {\n      return false;\n    }\n\n    let nodeText = n.text();\n    if (trim) {\n      nodeText = nodeText.trim();\n    }\n\n    return typeof text === 'string' ? nodeText === text : text.test(nodeText);\n  });\n  const hostNodes = textNodes.map((n) => {\n    // Traverse from the text node to the closest DOM node (aka host node)\n    let hostNode = n.parents().first();\n    while (typeof hostNode.type() !== 'string' && hostNode.parents().length > 0) {\n      hostNode = hostNode.parents().first();\n    }\n    return hostNode;\n  });\n  return hostNodes;\n}\n\n// We need to keep ref to original setTimeout to avoid SinonJS fake timers if enabled\nconst originalSetTimeout = window.setTimeout;\n\n/**\n * This is so the stack trace the developer sees is one that's\n * closer to their code (because async stack traces are hard to follow).\n *\n * The code is taken from\n * https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44632fba\n * 1579cb44f9f175be1ec46087/src/wait-for.js#L15-L19\n */\nfunction copyStackTrace(target: Error, source: Error) {\n  target.stack = source.stack!.replace(source.message, target.message);\n}\n\ninterface WaitForOptions {\n  interval?: number;\n  stackTraceError?: Error;\n  timeout?: number;\n}\n\n/**\n * Run an expectation until it succeeds or reaches the timeout. The timeout of 1500ms\n * is chosen to be under the default Karma test timeout of 2000ms. This function will\n * not work properly if fake timers are being used (since it expects the real setTimeout).\n *\n * The code is taken from\n * https://github.com/TheBrainFamily/wait-for-expect/blob/master/src/index.ts,\n * with slight modifications to support Karma (instead of Jest).\n *\n *\n * Example\n * The <App /> component does not render the header synchronously.\n * Therefore, we cannot check that the wrapper's text is equal to the string\n * immediately--this assertion will fail and cause the test to fail. To\n * remediate this issue, we can run the expectation until it succeeds:\n *\n * function App() {\n *   const [value, setValue] = useState(null);\n *   useEffect(() => {\n *     const timeoutId = setTimeout(() => setValue(\"some value\"), 100);\n *     return () => clearTimeout(timeoutId);\n *   }, []);\n *   return value === null ? null : <h1>The value is: {value}</h1>;\n * }\n *\n * it('renders value', async () => {\n *   const wrapper = mount(<App />);\n *   await waitFor(() =>\n *     wrapper.update();\n *     expect(wrapper.text()).to.equal(\"The value is: some value\")\n *   );\n * });\n */\nfunction _waitFor<T>(\n  f: () => T | Promise<T>,\n  { interval = 50, stackTraceError, timeout = 1500 }: WaitForOptions = {},\n): Promise<T> {\n  const maxTries = Math.ceil(timeout / interval);\n  let tries = 0;\n  return new Promise((resolve, reject) => {\n    const rejectOrRerun = (error: Error) => {\n      if (tries > maxTries) {\n        if (stackTraceError !== undefined) {\n          copyStackTrace(error, stackTraceError);\n        }\n        reject(error);\n        return;\n      }\n      originalSetTimeout(runExpectation, interval);\n    };\n\n    function runExpectation() {\n      tries += 1;\n      try {\n        Promise.resolve(f()).then(resolve).catch(rejectOrRerun);\n      } catch (error) {\n        // @ts-expect-error ts-migrate(2571) Object is of type 'unknown'\n        rejectOrRerun(error);\n      }\n    }\n\n    originalSetTimeout(runExpectation, 0);\n  });\n}\n\n/**\n * Wraps `_waitFor` in React's `act` testing utility. Used when the React component\n * updates during the execution of the callback (either because of indirect effects\n * being run or because of direct requests to update the component, like wrapper.update).\n * Prevents updates related to the callback from being affected by other updates\n * and more closely mimics how React runs in the browser. See\n * https://reactjs.org/docs/test-utils.html#act for more info on `act`.\n */\nexport async function waitFor<T>(callback: () => T | Promise<T>, options?: WaitForOptions): Promise<T> {\n  let result: T | Promise<T>;\n  // See https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44\n  // 632fba1579cb44f9f175be1ec46087/src/wait-for.js#L182-L184\n  const stackTraceError = new Error('STACK_TRACE_ERROR');\n\n  await act(async () => {\n    result = await _waitFor(callback, { stackTraceError, ...options });\n  });\n\n  // @ts-expect-error: either `waitFor` will throw or `result` will be assigned\n  return result;\n}\n\n/**\n * Finds all elements (that are rendered in the DOM) in `wrapper` that have an explicit\n * role of `role` specified. This is similar to `getAllByRole` from @testing-library/react\n * but is much simpler because of the shortcomings of Enzyme's API.\n */\nexport function findAllByRole<P, S, C>(wrapper: ReactWrapper<P, S, C>, role: string): ReactWrapper[] {\n  return wrapper\n    .find(`[role=\"${role}\"]`)\n    .hostNodes()\n    .map((n) => n);\n}\n\n/**\n * Finds a single element that has the specified role in the wrapper. If\n * there are 0 or more than 1 element that have that role, an error\n * is thrown. Returns the element in an enzyme wrapper.\n */\nexport function findByRole<P, S, C>(wrapper: ReactWrapper<P, S, C>, role: string): ReactWrapper {\n  const newWrappers = findAllByRole<P, S, C>(wrapper, role);\n  if (newWrappers.length !== 1) {\n    throw new Error(\n      `Expected to find 1 node but found ${newWrappers.length} nodes for role \"${role}\".\\n${wrapper.debug()}`,\n    );\n  }\n  return newWrappers[0];\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport { findByRole, findByText, waitFor } from './utils';\nimport { selectClasses } from '../common';\n\n/**\n * Clicks on the \"Clear\" button. In order for this function to work properly,\n * the `allowClear` prop must be set to `true`.\n */\nexport function clearAll<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): void {\n  getSelect().find(`.${selectClasses.clear}`).hostNodes().simulate('mousedown');\n}\n\n/**\n * Closes the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already closed or if the menu is unable to be closed.\n */\nexport async function closeMenu<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): Promise<void> {\n  if (!getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already closed\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not close\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Returns a string concatenating the labels for all selected options.\n */\nexport function getLabelText<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): string {\n  // Trim the text to avoid weird whitespace issues non-label elements being added.\n  // For example, the input mirror is an empty span with some whitespace that is\n  // nested under the selector but does not show up in the label text.\n  return getSelect().find(`.${selectClasses.selector}`).text().trim();\n}\n\n/**\n * Removes the `option` by clicking its \"X\" button. Can only be used with a <Select/>\n * component with `mode=\"multiple\"`. The provided strings must match the option label\n * exactly.\n */\nexport function removeMultiSelectOption<P, S, C>(getSelect: () => ReactWrapper<P, S, C>, option: string): void {\n  const optionItem = findByText(getSelect().find(`.${selectClasses.selector}`), option).closest(\n    `.${selectClasses.item}`,\n  );\n  const removeItem = optionItem.find(`.${selectClasses.removeItem}`).hostNodes();\n  removeItem.simulate('click');\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component with `mode=\"multiple\"`.\n * The provided strings must match the option labels exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function multiSelect<P, S, C>(\n  getSelect: () => ReactWrapper<P, S, C>,\n  options: (string | RegExp)[],\n): Promise<void> {\n  await openMenu(getSelect);\n  options.forEach((option) => {\n    findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  });\n  // Close the menu to indicate that selection has finished\n  await closeMenu(getSelect);\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component without a\n * mode. The provided string must match an option label exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function singleSelect<P, S, C>(\n  getSelect: () => ReactWrapper<P, S, C>,\n  option: string | RegExp,\n): Promise<void> {\n  await openMenu(getSelect);\n  findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  // Menu automatically closes for a single <Select/> (no mode=\"multiple\")\n}\n\n/**\n * Opens the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already opened or if the menu is unable to be opened.\n */\nexport async function openMenu<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): Promise<void> {\n  if (getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already open\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (!select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not open\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Opens the dropdown menu, finds all of the options in the dropdown, closes\n * the menu, and returns a list of the text of each option in order.\n */\nexport async function getAllOptions<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): Promise<string[]> {\n  await openMenu(getSelect);\n  const options = getSelect()\n    .find(`.${selectClasses.list}`)\n    .find(`.${selectClasses.option}`)\n    .map((option) => option.text());\n  await closeMenu(getSelect);\n  return options;\n}\n\n/**\n * Creates a new option for a Select with `mode=\"tags\"` by typing it into the input,\n * clicking on the option in the options list, and then closing the menu.\n */\nexport async function createNewOption<P, S, C>(getSelect: () => ReactWrapper<P, S, C>, option: string): Promise<void> {\n  const selectInput = findByRole(getSelect(), 'combobox');\n  selectInput.simulate('change', { target: { value: option } });\n  const optionList = getSelect().find(`.${selectClasses.list}`);\n  const optionItem = findByText(optionList, option);\n  optionItem.simulate('click');\n  await closeMenu(getSelect);\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport { findAllByRole, findByText } from './utils';\nimport type { GetTableRowByCellTextOptions, RowIdentifier, TableRows } from '../common';\nimport { createMarkdownTable } from '../common';\n\nfunction getColumnHeaderIndex<P, S, C>(tableWrapper: ReactWrapper<P, S, C>, columnHeaderName: string | RegExp): number {\n  const columnHeaders = findAllByRole(tableWrapper, 'columnheader');\n  const columnHeaderIndex = columnHeaders.findIndex((n) => {\n    try {\n      findByText(n, columnHeaderName);\n      return true;\n    } catch {\n      return false;\n    }\n  });\n\n  if (columnHeaderIndex === -1) {\n    throw new Error(`Unable to find a column with name \"${columnHeaderName}\"\\n${tableWrapper.debug()}`);\n  }\n\n  return columnHeaderIndex;\n}\n\n/**\n * Returns the table row that contains the specified `cellText`. The `cellText`\n * must be in the column with name `columnHeaderName` if it is specified. Otherwise,\n * the `cellText` must be in the first column. Throws an error if either multiple\n * rows or no rows can be found that match the given options. Also throws an error\n * if the column with name `columnHeaderName` cannot be found.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n * @param cellText The cell text that uniquely identifies the row.\n * @param columnHeaderName The name of the column to search the text for. If not provided,\n * the first column will be used.\n */\nexport function getTableRowByCellText<P, S, C>(\n  tableWrapper: ReactWrapper<P, S, C>,\n  cellText: string,\n  { columnHeaderName }: GetTableRowByCellTextOptions = {},\n): ReactWrapper {\n  const columnHeaderIndex = columnHeaderName === undefined ? 0 : getColumnHeaderIndex(tableWrapper, columnHeaderName);\n\n  const matchingRows = findAllByRole(tableWrapper, 'row')\n    // Skip first row (table header)\n    .slice(1)\n    .filter((row) => {\n      const cells = findAllByRole(row, 'cell');\n      const cell = cells[columnHeaderIndex];\n      try {\n        findByText(cell, cellText);\n        return true;\n      } catch {\n        return false;\n      }\n    });\n\n  if (matchingRows.length === 0) {\n    throw new Error(\n      `Unable to find a table row with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`,\n    );\n  }\n\n  if (matchingRows.length > 1) {\n    throw new Error(\n      `Found multiple table rows with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`,\n    );\n  }\n\n  return matchingRows[0].hostNodes();\n}\n\n/**\n * Converts a Du Bois table to a markdown table string. This means that each cell\n * is separated by a pipe (including the edges), the header row is on its own line\n * at the top, each data row is on its own line below, and the header row is separated\n * by a row of dashes from the data rows. This is useful for checking table contents\n * in tests.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n *\n * @example\n * The HTML table:\n * ```jsx\n *   <Table>\n *     <TableRow isHeader>\n *       <TableHeader>Name</TableHeader>\n *       <TableHeader>Fruit</TableHeader>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Alice</TableCell>\n *       <TableCell>Apple</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Brady</TableCell>\n *       <TableCell>Banana</TableCell>\n *     </TableRow>\n *   </Table>\n * ```\n *\n * The Markdown table:\n * ```md\n *   | Name | Fruit |\n *   | --- | --- |\n *   | Alice | Apple |\n *   | Brady | Banana |\n * ```\n */\nexport function toMarkdownTable<P, S, C>(tableWrapper: ReactWrapper<P, S, C>): string {\n  const { bodyRows, headerRow } = getTableRows(tableWrapper);\n  const columns = findAllByRole(headerRow, 'columnheader').map((column) => column.text());\n  const rows = bodyRows.map((row) => findAllByRole(row, 'cell').map((cell) => cell.text()));\n  return createMarkdownTable(columns, rows);\n}\n\n/**\n * Returns the header row and all body rows (non-header rows) in order. Assumes that the\n * `tableWrapper` has a single header row (as the first row) and the rest of the rows are\n * body rows.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n */\nexport function getTableRows<P, S, C>(tableWrapper: ReactWrapper<P, S, C>): TableRows<ReactWrapper> {\n  const [firstRow, ...restRows] = findAllByRole(tableWrapper, 'row');\n  return {\n    bodyRows: restRows,\n    headerRow: firstRow,\n  };\n}\n\n/**\n * Returns the table cell in the specified table row corresponding to the given\n * `columnHeaderName`. This is useful for checking that a row has a particular value\n * for a given column, especially when there are duplicate values in the column.\n *\n * @example\n * The HTML table:\n * ```jsx\n *   <Table>\n *     <TableRow isHeader>\n *       <TableHeader>Name</TableHeader>\n *       <TableHeader>Age</TableHeader>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Alex</TableCell>\n *       <TableCell>25</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Brenda</TableCell>\n *       <TableCell>39</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Carlos</TableCell>\n *       <TableCell>39</TableCell>\n *     </TableRow>\n *   </Table>\n * ```\n *\n * ```js\n * const result = getTableCellInRow(wrapper, { cellText: 'Carlos' }, 'Age');\n * expect(result.textContent).toEqual('39');\n * ```\n */\nexport function getTableCellInRow(\n  tableWrapper: ReactWrapper,\n  row: RowIdentifier,\n  columnHeaderName: string | RegExp,\n): ReactWrapper {\n  const tableRowWrapper = getTableRowByCellText(tableWrapper, row.cellText, { columnHeaderName: row.columnHeaderName });\n  const columnHeaderIndex = getColumnHeaderIndex(tableWrapper, columnHeaderName);\n  const cells = findAllByRole(tableRowWrapper, 'cell');\n  const cell = cells[columnHeaderIndex];\n  return cell;\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nexport * as selectEvent from './selectEvent';\n\nexport * from './table';\n\n/**\n * Open a dropdown menu by simulating a pointerDown event on the dropdown button.\n *\n * @param dropdownButton - The Dropdown Trigger button that opens the menu when clicked.\n */\nexport const openDropdownMenu = <P, S, C>(dropdownButton: ReactWrapper<P, S, C>) => {\n  dropdownButton.hostNodes().simulate('pointerDown', { button: 0, ctrlKey: false });\n};\n"],"names":["findByText","wrapper","text","queryOptions","newWrappers","findAllByText","length","Error","debug","trim","arguments","undefined","textNodes","findWhere","n","type","getDOMNode","children","nodeText","test","hostNodes","map","hostNode","parents","first","originalSetTimeout","window","setTimeout","copyStackTrace","target","source","stack","replace","message","_waitFor","f","interval","stackTraceError","timeout","maxTries","Math","ceil","tries","Promise","resolve","reject","rejectOrRerun","error","runExpectation","then","catch","waitFor","callback","options","result","act","findAllByRole","role","find","findByRole","clearAll","getSelect","selectClasses","clear","simulate","closeMenu","open","exists","selector","select","getLabelText","removeMultiSelectOption","option","optionItem","closest","item","removeItem","multiSelect","openMenu","forEach","list","singleSelect","getAllOptions","createNewOption","selectInput","value","optionList","getColumnHeaderIndex","tableWrapper","columnHeaderName","columnHeaders","columnHeaderIndex","findIndex","getTableRowByCellText","cellText","matchingRows","slice","filter","row","cells","cell","toMarkdownTable","bodyRows","headerRow","getTableRows","columns","column","rows","createMarkdownTable","firstRow","restRows","getTableCellInRow","tableRowWrapper","openDropdownMenu","dropdownButton","button","ctrlKey"],"mappings":"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"}