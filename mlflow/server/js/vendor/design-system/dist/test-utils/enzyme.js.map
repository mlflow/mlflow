{"version":3,"file":"enzyme.js","sources":["../../src/test-utils/enzyme/utils.ts","../../src/test-utils/enzyme/selectEvent.ts","../../src/test-utils/enzyme/table.ts","../../src/test-utils/enzyme/index.ts"],"sourcesContent":["// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\nimport { act } from 'react-dom/test-utils';\n\ninterface QueryOptions {\n  /** Whether to trim the whitespace from DOM text using `String.prototype.trim` */\n  trim?: boolean;\n}\n\n/**\n * Finds a single element that contains the specified text in the wrapper. If\n * there are 0 or more than 1 element that contains the specified text, an error\n * is thrown. Returns the element in an enzyme wrapper.\n */\nexport function findByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  queryOptions?: QueryOptions,\n) {\n  const newWrappers = findAllByText<P, S, C>(wrapper, text, queryOptions);\n  if (newWrappers.length !== 1) {\n    throw new Error(\n      `Expected to find 1 node but found ${newWrappers.length} nodes for text \"${text}\".\\n${wrapper.debug()}`,\n    );\n  }\n  return newWrappers[0];\n}\n\n/**\n * Finds all elements that contain the specified text. To avoid duplicate results,\n * only the parents of text nodes are returned.\n */\nexport function findAllByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  { trim = false }: QueryOptions = {},\n) {\n  const textNodes = wrapper.findWhere((n) => {\n    if (typeof n.type() !== 'string' || n.getDOMNode().children.length !== 0) {\n      return false;\n    }\n\n    let nodeText = n.text();\n    if (trim) {\n      nodeText = nodeText.trim();\n    }\n\n    return typeof text === 'string' ? nodeText === text : text.test(nodeText);\n  });\n  const hostNodes = textNodes.map((n) => {\n    // Traverse from the text node to the closest DOM node (aka host node)\n    let hostNode = n.parents().first();\n    while (typeof hostNode.type() !== 'string' && hostNode.parents().length > 0) {\n      hostNode = hostNode.parents().first();\n    }\n    return hostNode;\n  });\n  return hostNodes;\n}\n\n// We need to keep ref to original setTimeout to avoid SinonJS fake timers if enabled\nconst originalSetTimeout = window.setTimeout;\n\n/**\n * This is so the stack trace the developer sees is one that's\n * closer to their code (because async stack traces are hard to follow).\n *\n * The code is taken from\n * https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44632fba\n * 1579cb44f9f175be1ec46087/src/wait-for.js#L15-L19\n */\nfunction copyStackTrace(target: Error, source: Error) {\n  target.stack = source.stack!.replace(source.message, target.message);\n}\n\ninterface WaitForOptions {\n  interval?: number;\n  stackTraceError?: Error;\n  timeout?: number;\n}\n\n/**\n * Run an expectation until it succeeds or reaches the timeout. The timeout of 1500ms\n * is chosen to be under the default Karma test timeout of 2000ms. This function will\n * not work properly if fake timers are being used (since it expects the real setTimeout).\n *\n * The code is taken from\n * https://github.com/TheBrainFamily/wait-for-expect/blob/master/src/index.ts,\n * with slight modifications to support Karma (instead of Jest).\n *\n *\n * Example\n * The <App /> component does not render the header synchronously.\n * Therefore, we cannot check that the wrapper's text is equal to the string\n * immediately--this assertion will fail and cause the test to fail. To\n * remediate this issue, we can run the expectation until it succeeds:\n *\n * function App() {\n *   const [value, setValue] = useState(null);\n *   useEffect(() => {\n *     const timeoutId = setTimeout(() => setValue(\"some value\"), 100);\n *     return () => clearTimeout(timeoutId);\n *   }, []);\n *   return value === null ? null : <h1>The value is: {value}</h1>;\n * }\n *\n * it('renders value', async () => {\n *   const wrapper = mount(<App />);\n *   await waitFor(() =>\n *     wrapper.update();\n *     expect(wrapper.text()).to.equal(\"The value is: some value\")\n *   );\n * });\n */\nfunction _waitFor<T>(\n  f: () => T | Promise<T>,\n  { interval = 50, stackTraceError, timeout = 1500 }: WaitForOptions = {},\n): Promise<T> {\n  const maxTries = Math.ceil(timeout / interval);\n  let tries = 0;\n  return new Promise((resolve, reject) => {\n    const rejectOrRerun = (error: Error) => {\n      if (tries > maxTries) {\n        if (stackTraceError !== undefined) {\n          copyStackTrace(error, stackTraceError);\n        }\n        reject(error);\n        return;\n      }\n      originalSetTimeout(runExpectation, interval);\n    };\n\n    function runExpectation() {\n      tries += 1;\n      try {\n        Promise.resolve(f()).then(resolve).catch(rejectOrRerun);\n      } catch (error) {\n        // @ts-expect-error ts-migrate(2571) Object is of type 'unknown'\n        rejectOrRerun(error);\n      }\n    }\n\n    originalSetTimeout(runExpectation, 0);\n  });\n}\n\n/**\n * Wraps `_waitFor` in React's `act` testing utility. Used when the React component\n * updates during the execution of the callback (either because of indirect effects\n * being run or because of direct requests to update the component, like wrapper.update).\n * Prevents updates related to the callback from being affected by other updates\n * and more closely mimics how React runs in the browser. See\n * https://reactjs.org/docs/test-utils.html#act for more info on `act`.\n */\nexport async function waitFor<T>(callback: () => T | Promise<T>, options?: WaitForOptions): Promise<T> {\n  let result: T | Promise<T>;\n  // See https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44\n  // 632fba1579cb44f9f175be1ec46087/src/wait-for.js#L182-L184\n  const stackTraceError = new Error('STACK_TRACE_ERROR');\n\n  await act(async () => {\n    result = await _waitFor(callback, { stackTraceError, ...options });\n  });\n\n  // @ts-expect-error: either `waitFor` will throw or `result` will be assigned\n  return result;\n}\n\n/**\n * Finds all elements (that are rendered in the DOM) in `wrapper` that have an explicit\n * role of `role` specified. This is similar to `getAllByRole` from @testing-library/react\n * but is much simpler because of the shortcomings of Enzyme's API.\n */\nexport function findAllByRole<P, S, C>(wrapper: ReactWrapper<P, S, C>, role: string): ReactWrapper[] {\n  return wrapper\n    .find(`[role=\"${role}\"]`)\n    .hostNodes()\n    .map((n) => n);\n}\n\n/**\n * Finds a single element that has the specified role in the wrapper. If\n * there are 0 or more than 1 element that have that role, an error\n * is thrown. Returns the element in an enzyme wrapper.\n */\nexport function findByRole<P, S, C>(wrapper: ReactWrapper<P, S, C>, role: string): ReactWrapper {\n  const newWrappers = findAllByRole<P, S, C>(wrapper, role);\n  if (newWrappers.length !== 1) {\n    throw new Error(\n      `Expected to find 1 node but found ${newWrappers.length} nodes for role \"${role}\".\\n${wrapper.debug()}`,\n    );\n  }\n  return newWrappers[0];\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport { findByRole, findByText, waitFor } from './utils';\nimport { selectClasses } from '../common';\n\n/**\n * Clicks on the \"Clear\" button. In order for this function to work properly,\n * the `allowClear` prop must be set to `true`.\n */\nexport function clearAll<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): void {\n  getSelect().find(`.${selectClasses.clear}`).hostNodes().simulate('mousedown');\n}\n\n/**\n * Closes the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already closed or if the menu is unable to be closed.\n */\nexport async function closeMenu<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): Promise<void> {\n  if (!getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already closed\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not close\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Returns a string concatenating the labels for all selected options.\n */\nexport function getLabelText<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): string {\n  // Trim the text to avoid weird whitespace issues non-label elements being added.\n  // For example, the input mirror is an empty span with some whitespace that is\n  // nested under the selector but does not show up in the label text.\n  return getSelect().find(`.${selectClasses.selector}`).text().trim();\n}\n\n/**\n * Removes the `option` by clicking its \"X\" button. Can only be used with a <Select/>\n * component with `mode=\"multiple\"`. The provided strings must match the option label\n * exactly.\n */\nexport function removeMultiSelectOption<P, S, C>(getSelect: () => ReactWrapper<P, S, C>, option: string): void {\n  const optionItem = findByText(getSelect().find(`.${selectClasses.selector}`), option).closest(\n    `.${selectClasses.item}`,\n  );\n  const removeItem = optionItem.find(`.${selectClasses.removeItem}`).hostNodes();\n  removeItem.simulate('click');\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component with `mode=\"multiple\"`.\n * The provided strings must match the option labels exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function multiSelect<P, S, C>(\n  getSelect: () => ReactWrapper<P, S, C>,\n  options: (string | RegExp)[],\n): Promise<void> {\n  await openMenu(getSelect);\n  options.forEach((option) => {\n    findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  });\n  // Close the menu to indicate that selection has finished\n  await closeMenu(getSelect);\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component without a\n * mode. The provided string must match an option label exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function singleSelect<P, S, C>(\n  getSelect: () => ReactWrapper<P, S, C>,\n  option: string | RegExp,\n): Promise<void> {\n  await openMenu(getSelect);\n  findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  // Menu automatically closes for a single <Select/> (no mode=\"multiple\")\n}\n\n/**\n * Opens the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already opened or if the menu is unable to be opened.\n */\nexport async function openMenu<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): Promise<void> {\n  if (getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already open\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (!select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not open\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Opens the dropdown menu, finds all of the options in the dropdown, closes\n * the menu, and returns a list of the text of each option in order.\n */\nexport async function getAllOptions<P, S, C>(getSelect: () => ReactWrapper<P, S, C>): Promise<string[]> {\n  await openMenu(getSelect);\n  const options = getSelect()\n    .find(`.${selectClasses.list}`)\n    .find(`.${selectClasses.option}`)\n    .map((option) => option.text());\n  await closeMenu(getSelect);\n  return options;\n}\n\n/**\n * Creates a new option for a Select with `mode=\"tags\"` by typing it into the input,\n * clicking on the option in the options list, and then closing the menu.\n */\nexport async function createNewOption<P, S, C>(getSelect: () => ReactWrapper<P, S, C>, option: string): Promise<void> {\n  const selectInput = findByRole(getSelect(), 'combobox');\n  selectInput.simulate('change', { target: { value: option } });\n  const optionList = getSelect().find(`.${selectClasses.list}`);\n  const optionItem = findByText(optionList, option);\n  optionItem.simulate('click');\n  await closeMenu(getSelect);\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport { findAllByRole, findByText } from './utils';\nimport type { GetTableRowByCellTextOptions, RowIdentifier, TableRows } from '../common';\nimport { createMarkdownTable } from '../common';\n\nfunction getColumnHeaderIndex<P, S, C>(tableWrapper: ReactWrapper<P, S, C>, columnHeaderName: string | RegExp): number {\n  const columnHeaders = findAllByRole(tableWrapper, 'columnheader');\n  const columnHeaderIndex = columnHeaders.findIndex((n) => {\n    try {\n      findByText(n, columnHeaderName);\n      return true;\n    } catch {\n      return false;\n    }\n  });\n\n  if (columnHeaderIndex === -1) {\n    throw new Error(`Unable to find a column with name \"${columnHeaderName}\"\\n${tableWrapper.debug()}`);\n  }\n\n  return columnHeaderIndex;\n}\n\n/**\n * Returns the table row that contains the specified `cellText`. The `cellText`\n * must be in the column with name `columnHeaderName` if it is specified. Otherwise,\n * the `cellText` must be in the first column. Throws an error if either multiple\n * rows or no rows can be found that match the given options. Also throws an error\n * if the column with name `columnHeaderName` cannot be found.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n * @param cellText The cell text that uniquely identifies the row.\n * @param columnHeaderName The name of the column to search the text for. If not provided,\n * the first column will be used.\n */\nexport function getTableRowByCellText<P, S, C>(\n  tableWrapper: ReactWrapper<P, S, C>,\n  cellText: string,\n  { columnHeaderName }: GetTableRowByCellTextOptions = {},\n): ReactWrapper {\n  const columnHeaderIndex = columnHeaderName === undefined ? 0 : getColumnHeaderIndex(tableWrapper, columnHeaderName);\n\n  const matchingRows = findAllByRole(tableWrapper, 'row')\n    // Skip first row (table header)\n    .slice(1)\n    .filter((row) => {\n      const cells = findAllByRole(row, 'cell');\n      const cell = cells[columnHeaderIndex];\n      try {\n        findByText(cell, cellText);\n        return true;\n      } catch {\n        return false;\n      }\n    });\n\n  if (matchingRows.length === 0) {\n    throw new Error(\n      `Unable to find a table row with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`,\n    );\n  }\n\n  if (matchingRows.length > 1) {\n    throw new Error(\n      `Found multiple table rows with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`,\n    );\n  }\n\n  return matchingRows[0].hostNodes();\n}\n\n/**\n * Converts a Du Bois table to a markdown table string. This means that each cell\n * is separated by a pipe (including the edges), the header row is on its own line\n * at the top, each data row is on its own line below, and the header row is separated\n * by a row of dashes from the data rows. This is useful for checking table contents\n * in tests.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n *\n * @example\n * The HTML table:\n * ```jsx\n *   <Table>\n *     <TableRow isHeader>\n *       <TableHeader>Name</TableHeader>\n *       <TableHeader>Fruit</TableHeader>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Alice</TableCell>\n *       <TableCell>Apple</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Brady</TableCell>\n *       <TableCell>Banana</TableCell>\n *     </TableRow>\n *   </Table>\n * ```\n *\n * The Markdown table:\n * ```md\n *   | Name | Fruit |\n *   | --- | --- |\n *   | Alice | Apple |\n *   | Brady | Banana |\n * ```\n */\nexport function toMarkdownTable<P, S, C>(tableWrapper: ReactWrapper<P, S, C>): string {\n  const { bodyRows, headerRow } = getTableRows(tableWrapper);\n  const columns = findAllByRole(headerRow, 'columnheader').map((column) => column.text());\n  const rows = bodyRows.map((row) => findAllByRole(row, 'cell').map((cell) => cell.text()));\n  return createMarkdownTable(columns, rows);\n}\n\n/**\n * Returns the header row and all body rows (non-header rows) in order. Assumes that the\n * `tableWrapper` has a single header row (as the first row) and the rest of the rows are\n * body rows.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n */\nexport function getTableRows<P, S, C>(tableWrapper: ReactWrapper<P, S, C>): TableRows<ReactWrapper> {\n  const [firstRow, ...restRows] = findAllByRole(tableWrapper, 'row');\n  return {\n    bodyRows: restRows,\n    headerRow: firstRow,\n  };\n}\n\n/**\n * Returns the table cell in the specified table row corresponding to the given\n * `columnHeaderName`. This is useful for checking that a row has a particular value\n * for a given column, especially when there are duplicate values in the column.\n *\n * @example\n * The HTML table:\n * ```jsx\n *   <Table>\n *     <TableRow isHeader>\n *       <TableHeader>Name</TableHeader>\n *       <TableHeader>Age</TableHeader>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Alex</TableCell>\n *       <TableCell>25</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Brenda</TableCell>\n *       <TableCell>39</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Carlos</TableCell>\n *       <TableCell>39</TableCell>\n *     </TableRow>\n *   </Table>\n * ```\n *\n * ```js\n * const result = getTableCellInRow(wrapper, { cellText: 'Carlos' }, 'Age');\n * expect(result.textContent).toEqual('39');\n * ```\n */\nexport function getTableCellInRow(\n  tableWrapper: ReactWrapper,\n  row: RowIdentifier,\n  columnHeaderName: string | RegExp,\n): ReactWrapper {\n  const tableRowWrapper = getTableRowByCellText(tableWrapper, row.cellText, { columnHeaderName: row.columnHeaderName });\n  const columnHeaderIndex = getColumnHeaderIndex(tableWrapper, columnHeaderName);\n  const cells = findAllByRole(tableRowWrapper, 'cell');\n  const cell = cells[columnHeaderIndex];\n  return cell;\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nexport * as selectEvent from './selectEvent';\n\nexport * from './table';\n\n/**\n * Open a dropdown menu by simulating a pointerDown event on the dropdown button.\n *\n * @param dropdownButton - The Dropdown Trigger button that opens the menu when clicked.\n */\nexport const openDropdownMenu = <P, S, C>(dropdownButton: ReactWrapper<P, S, C>) => {\n  dropdownButton.hostNodes().simulate('pointerDown', { button: 0, ctrlKey: false });\n};\n"],"names":["findByText","wrapper","text","queryOptions","newWrappers","findAllByText","length","Error","debug","trim","textNodes","findWhere","n","type","getDOMNode","children","nodeText","test","hostNodes","map","hostNode","parents","first","originalSetTimeout","window","setTimeout","copyStackTrace","target","source","stack","replace","message","_waitFor","f","interval","stackTraceError","timeout","maxTries","Math","ceil","tries","Promise","resolve","reject","rejectOrRerun","error","undefined","runExpectation","then","catch","waitFor","callback","options","result","act","findAllByRole","role","find","findByRole","clearAll","getSelect","selectClasses","clear","simulate","closeMenu","open","exists","selector","select","getLabelText","removeMultiSelectOption","option","optionItem","closest","item","removeItem","multiSelect","openMenu","forEach","list","singleSelect","getAllOptions","createNewOption","selectInput","value","optionList","getColumnHeaderIndex","tableWrapper","columnHeaderName","columnHeaders","columnHeaderIndex","findIndex","getTableRowByCellText","cellText","matchingRows","slice","filter","row","cells","cell","toMarkdownTable","bodyRows","headerRow","getTableRows","columns","column","rows","createMarkdownTable","firstRow","restRows","getTableCellInRow","tableRowWrapper","openDropdownMenu","dropdownButton","button","ctrlKey"],"mappings":"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"}