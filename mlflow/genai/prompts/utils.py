import re
import threading
import time
from typing import Any

# Default TTL for prompt cache (60 seconds, matching LangFuse default)
DEFAULT_PROMPT_CACHE_TTL_SECONDS = 60


def format_prompt(prompt: str, **values: Any) -> str:
    """Format double-curly variables in the prompt template."""
    for key, value in values.items():
        # Escape backslashes in the replacement string to prevent re.sub from interpreting
        # them as escape sequences (e.g. \u being treated as Unicode escape)
        replacement = str(value).replace("\\", "\\\\")
        prompt = re.sub(r"\{\{\s*" + key + r"\s*\}\}", replacement, prompt)
    return prompt


class PromptCache:
    """
    Thread-safe singleton cache for prompts with TTL support.

    This cache stores prompts to avoid repeated API calls when fetching
    prompts by name/version/label. Items expire after a configurable TTL.

    Usage:
        cache = PromptCache.get_instance()
        key = PromptCache.generate_cache_key("my-prompt", version=1)
        cache.set(key, prompt_value, ttl_seconds=300)
        prompt = cache.get(key)
    """

    _instance_lock = threading.RLock()
    _instance: "PromptCache | None" = None  # clint: disable=implicit-optional

    @classmethod
    def get_instance(cls) -> "PromptCache":
        """Get the singleton instance of PromptCache."""
        if cls._instance is None:
            with cls._instance_lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance

    @classmethod
    def _reset_instance(cls) -> None:
        """Reset the singleton instance (for testing purposes only)."""
        with cls._instance_lock:
            if cls._instance is not None:
                cls._instance._cache.clear()
            cls._instance = None

    def __init__(self):
        self._cache: dict[str, tuple[Any, float]] = {}  # key -> (value, expiry_timestamp)
        self._lock = threading.RLock()

    def get(self, key: str) -> Any | None:
        """
        Get a prompt from the cache.

        Returns the cached value, or None if not found or expired.
        Expired items are removed on access.
        """
        with self._lock:
            item = self._cache.get(key)
            if item is None:
                return None
            value, expiry = item
            if time.time() > expiry:
                del self._cache[key]
                return None
            return value

    def set(
        self, key: str, value: Any, ttl_seconds: float = DEFAULT_PROMPT_CACHE_TTL_SECONDS
    ) -> None:
        """
        Store a prompt in the cache.

        Args:
            key: Cache key generated by generate_cache_key()
            value: The prompt value to cache
            ttl_seconds: Time-to-live in seconds (default 60)
        """
        with self._lock:
            self._cache[key] = (value, time.time() + ttl_seconds)

    def invalidate(self, prompt_name: str) -> None:
        """
        Invalidate all cached versions/labels of a prompt.

        Args:
            prompt_name: The prompt name to invalidate
        """
        with self._lock:
            keys_to_remove = [k for k in self._cache if k.startswith(prompt_name)]
            for key in keys_to_remove:
                del self._cache[key]

    def clear(self) -> None:
        """Clear all cached prompts."""
        with self._lock:
            self._cache.clear()

    @staticmethod
    def generate_cache_key(
        name: str,
        version: int | None = None,
        label: str | None = None,
    ) -> str:
        """
        Generate a cache key for a prompt.

        Args:
            name: Prompt name
            version: Prompt version (mutually exclusive with label)
            label: Prompt label (mutually exclusive with version)

        Returns:
            A unique cache key string

        Raises:
            ValueError: If both version and label are provided
        """
        if version is not None and label is not None:
            raise ValueError("Cannot specify both version and label")

        if version is not None:
            return f"{name}-version:{version}"
        elif label is not None:
            return f"{name}-label:{label}"
        else:
            return f"{name}-latest"
