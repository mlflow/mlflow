module.exports = async ({ github, context }) => {
  const { owner, repo } = context.repo;
  const pr = context.payload.pull_request;

  const GENERATED_PATTERNS = [
    /^mlflow\/protos\/.*\.pyi$/,
    /_pb2(_grpc)?\.py$/,
    /^uv\.lock$/,
    /package-lock\.json$/,
    /^docs\/api_reference\/source\/rest-api\.rst$/,
  ];

  const THRESHOLDS = [
    { label: "size/XS", max: 9 },
    { label: "size/S", max: 49 },
    { label: "size/M", max: 199 },
    { label: "size/L", max: 499 },
    { label: "size/XL", max: Infinity },
  ];

  const files = await github.paginate(github.rest.pulls.listFiles, {
    owner,
    repo,
    pull_number: pr.number,
  });

  let totalChanges = 0;
  for (const file of files) {
    if (GENERATED_PATTERNS.some((p) => p.test(file.filename))) continue;

    if (file.filename.endsWith(".java")) {
      try {
        const url = `https://raw.githubusercontent.com/${owner}/${repo}/${pr.head.sha}/${file.filename}`;
        const resp = await fetch(url, { headers: { Range: "bytes=0-255" } });
        if (!resp.ok) {
          console.warn(`Failed to fetch ${file.filename}: ${resp.status}`);
          // If we can't check, include it in the count
        } else {
          const text = await resp.text();
          if (text.includes("Generated by the protocol buffer compiler")) continue;
        }
      } catch (e) {
        console.error(`Error fetching ${file.filename}:`, e);
        // If we can't check, include it in the count
      }
    }

    totalChanges += file.additions + file.deletions;
  }

  const sizeLabel = THRESHOLDS.find((t) => totalChanges <= t.max).label;
  console.log(`Total: ${totalChanges}, Label: ${sizeLabel}`);

  const existing = pr.labels.map(({ name }) => name);

  for (const name of existing.filter((n) => n.startsWith("size/") && n !== sizeLabel)) {
    await github.rest.issues.removeLabel({ owner, repo, issue_number: pr.number, name });
  }

  if (!existing.includes(sizeLabel)) {
    await github.rest.issues.addLabels({
      owner,
      repo,
      issue_number: pr.number,
      labels: [sizeLabel],
    });
  }
};
